stages:
  - check_secrets
  - create_dev
  - deploy_dev
  - approve
  - create_prod
  - deploy_prod
  - manual


variables:
  WORK_DIR: "$CI_PROJECT_DIR"
  TF_PLUGIN_CACHE_DIR: "$CI_PROJECT_DIR/plugin-cache"
  TG_PARALLELISM: 10


cache:
  key: plugin-cache
  paths:
    - plugin-cache/



.install_default_deps:
  before_script:
    - |
      if command -v apt &> /dev/null; then
          apt update && apt install -y make coreutils jq curl sed grep openssh-client git
      elif command -v apk &> /dev/null; then
          apk --no-cache add make coreutils jq curl sed grep openssh git
      else
          echo "âž–âž– ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÐ¼Ñ‹Ð¹ Ð¿Ð°ÐºÐµÑ‚Ð½Ñ‹Ð¹ Ð¼ÐµÐ½ÐµÐ´Ð¶ÐµÑ€ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½."
          exit 1; fi



.terragrunt_config:
  script:
    # INSTALL PACKAGES
    - |
      if command -v apt &> /dev/null; then
          apt update && apt install -y python3 py3-pip py3-setuptools py3-wheel aws-cli
      elif command -v apk &> /dev/null; then
          apk --no-cache add python3 py3-pip py3-setuptools py3-wheel aws-cli
      else
          echo "âž–âž– ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÐ¼Ñ‹Ð¹ Ð¿Ð°ÐºÐµÑ‚Ð½Ñ‹Ð¹ Ð¼ÐµÐ½ÐµÐ´Ð¶ÐµÑ€ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½."
          exit 1; fi


    # DECRYPT SECRETS
    - make decrypt_secrets
    
    # SETUP SECRETS
    - export YC_SERVICE_ACCOUNT_KEY_FILE=${WORK_DIR}/secrets/admin/yc_admin_sa_key.json
    - set -a && source ${WORK_DIR}/secrets/admin/remote-backend.env && set +a

    # CHECK
    - echo "ðŸ“¦ PWD                          >>>     $(pwd)"
    - echo "ðŸ“¦ Ð¡Ð¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸Ð¸        >>>     $(ls -la)"
    - echo "ðŸ“¦ YC_SERVICE_ACCOUNT_KEY_FILE  >>>     $(cat ${YC_SERVICE_ACCOUNT_KEY_FILE} | head -c 30)"
    - echo "ðŸ“¦ AWS_ACCESS_KEY_ID            >>>     $(echo ${AWS_ACCESS_KEY_ID} | head -c 300)"
    
    # CACHE
    - mkdir -p $TF_PLUGIN_CACHE_DIR

    # CONFIGURE TERRAFORM TO USE YANDEX MIRROR
    - |
      cat <<EOF > ~/.terraformrc
      provider_installation {
        network_mirror {
          url = "https://terraform-mirror.yandexcloud.net/"
          include = ["registry.terraform.io/*/*"]
        }
        direct {
          exclude = ["registry.terraform.io/*/*"]
        }
      }
      EOF
    
    # TERRAGRUNT CHECK
    - terragrunt hcl fmt
    - terragrunt hcl fmt --check
    - terragrunt init --all -upgrade
    - terragrunt run --all validate
  


.ansible_config:
  script:
    # DECRYPT SECRETS
    - make decrypt_secrets
    
    # CHECK
    - echo "ðŸ“¦ PWD                          >>>     $(pwd)"
    - echo "ðŸ“¦ Ð¡Ð¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸Ð¸        >>>     $(ls -la)"
    - echo "ðŸ“¦ YC_SSH_KEY                   >>>     $(cat ${WORK_DIR}/secrets/admin/yc_ssh_key | head -c 30)"
    - echo "ðŸ“¦ GITLAB_ENV                   >>>     $(cat ${WORK_DIR}/secrets/ops/gitlab.env | head -c 300)"
    - echo "ðŸ“¦ SA_COMPUTE_VIEWER            >>>     $(cat ${WORK_DIR}/secrets/ops/yc_compute_viewer_sa_key.json | head -c 50)"
    - echo "ðŸ“¦ SA_SERVERLESS_DEPLOY         >>>     $(cat ${WORK_DIR}/secrets/ops/yc_serverless_deploy_sa_key.json | head -c 50)"
    - echo "ðŸ“¦ ENV_APP_SECRET               >>>     $(cat ${WORK_DIR}/secrets/dev/totemlounge/website/.env | head -c 30)"

    # SETUP SECRETS
    - chmod 600 ${WORK_DIR}/secrets/admin/yc_ssh_key
    - eval $(ssh-agent -s) && ssh-add ${WORK_DIR}/secrets/admin/yc_ssh_key 

    # GET YC CONTAINER REGISTRY ID
    - export YC_SERVICE_ACCOUNT_KEY_FILE=${WORK_DIR}/secrets/ops/yc_serverless_deploy_sa_key.json
    - set -a && source ${WORK_DIR}/secrets/admin/remote-backend.env && set +a
    - export REGISTRY_ID=$(terragrunt output -json --working-dir ${WORK_DIR}/infrastructure/${ENV}/registry | jq -r '.registry_id.value')
    
    # AUTH TO REGISTRY
    - |
      yc config profile create temp
      yc config set service-account-key "$YC_SERVICE_ACCOUNT_KEY_FILE"
      yc config set cloud-id "$YC_CLOUD_ID"
      yc config set folder-id "$YC_FOLDER_ID"
      docker login --username iam --password-stdin cr.yandex <<< "$(yc iam create-token)"

    - export ANSIBLE_CONFIG=${WORK_DIR}/infrastructure/ansible/ansible.cfg

    - echo "ðŸ“¦ PWD                          >>>     $(echo ${REGISTRY_ID})"

check_secrets:
  stage: check_secrets
  image: frolvlad/alpine-bash
  before_script: 
    - !reference [.install_default_deps, before_script]
  script:
    - make check_secrets
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH'


create_dev:
  stage: create_dev
  image: alpine/terragrunt:tf1.11.4
  variables:
    SOPS_KEYS: "admin"  
  before_script: 
    - !reference [.install_default_deps, before_script]
  script:
    - !reference [.terragrunt_config, script]
    - make create ENV=dev
  needs: [check_secrets]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH'




deploy_dev:
  stage: deploy_dev
  image: arkselen/ci:v6
  variables:
    ENV: "dev"
    SOPS_KEYS: "admin ops dev"
  script:
    - !reference [.ansible_config, script]
    - make deploy ENV=dev
  needs: [create_dev]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH'




approve:
  stage: approve
  image: frolvlad/alpine-bash
  before_script: 
    - !reference [.install_default_deps, before_script]
  script:
    - make approve
  needs: [deploy_dev]
  # when: manual
  allow_failure: false
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH'




create_prod:
  stage: create_prod
  image: alpine/terragrunt:tf1.11.4
  variables:
    SOPS_KEYS: "admin"
  before_script: 
    - !reference [.install_default_deps, before_script]
  script:
    - !reference [.terragrunt_config, script]
    - make create ENV=prod
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH




deploy_prod:
  stage: deploy_prod
  image: arkselen/ci:v6
  variables:
    ENV: "prod"
    SOPS_KEYS: "admin ops prod"
  script:
    - !reference [.ansible_config, script]
    - make deploy ENV=prod
  needs: [create_prod]
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH



# MANUAL_JOBS>>>
rollback_infra_prod:
  stage: manual
  image: alpine/terragrunt:tf1.11.4
  variables:
    SOPS_KEYS: "admin"
    ENV: "prod"
  before_script:
    - !reference [.install_default_deps, before_script]
  script:
    - git fetch origin main
    - git checkout $(git log --merges origin/main --pretty=format:"%H" | sed -n 2p)
    - !reference [.terragrunt_config, script]
    - make create ENV=prod
  when: manual
  allow_failure: false
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'


rollback_deploy_prod:
  stage: manual
  image: arkselen/ci:v6
  variables:
    SOPS_KEYS: "admin ops prod"
    ENV: "prod"
  script:
    - git fetch origin main
    - git checkout $(git log --merges origin/main --pretty=format:"%H" | sed -n 2p)
    - !reference [.ansible_config, script]
    - make deploy ENV=prod
  when: manual
  allow_failure: false
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'




destroy_dev:
  stage: manual
  image: alpine/terragrunt:tf1.11.4
  variables:
    SOPS_KEYS: "admin"
  before_script: 
    - !reference [.install_default_deps, before_script]
  script:
    - !reference [.terragrunt_config, script]
    - make destroy ENV=dev
  when: manual
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH


destroy_prod:
  stage: manual
  image: alpine/terragrunt:tf1.11.4
  variables:
    SOPS_KEYS: "admin"
  before_script: 
    - !reference [.install_default_deps, before_script]
  script:
    - !reference [.terragrunt_config, script]
    - make destroy ENV=prod
  when: manual
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH






# SUBSERVICE
deploy_cloud_function_trigger:
  stage: deploy_dev
  image: arkselen/ci:v6
  variables:
    ENV: "dev"
    SOPS_KEYS: "admin ops dev"
  script:
    # - !reference [.ansible_config, script]
    # DECRYPT SECRETS
    - make decrypt_secrets
    
    # CHECK
    - echo "ðŸ“¦ PWD                          >>>     $(pwd)"
    - echo "ðŸ“¦ Ð¡Ð¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸Ð¸        >>>     $(ls -la)"
    - echo "ðŸ“¦ YC_SSH_KEY                   >>>     $(cat ${WORK_DIR}/secrets/admin/yc_ssh_key | head -c 30)"
    - echo "ðŸ“¦ GITLAB_ENV                   >>>     $(cat ${WORK_DIR}/secrets/ops/gitlab.env | head -c 300)"
    - echo "ðŸ“¦ SA_COMPUTE_VIEWER            >>>     $(cat ${WORK_DIR}/secrets/ops/yc_compute_viewer_sa_key.json | head -c 50)"
    - echo "ðŸ“¦ SA_SERVERLESS_DEPLOY         >>>     $(cat ${WORK_DIR}/secrets/ops/yc_serverless_deploy_sa_key.json | head -c 50)"
    - echo "ðŸ“¦ ENV_APP_SECRET               >>>     $(cat ${WORK_DIR}/secrets/dev/totemlounge/website/.env | head -c 30)"

    # SETUP SECRETS
    - chmod 600 ${WORK_DIR}/secrets/admin/yc_ssh_key
    - eval $(ssh-agent -s) && ssh-add ${WORK_DIR}/secrets/admin/yc_ssh_key 

    # GET YC CONTAINER REGISTRY ID
    - export YC_SERVICE_ACCOUNT_KEY_FILE=${WORK_DIR}/secrets/ops/yc_serverless_deploy_sa_key.json
    - set -a && source ${WORK_DIR}/secrets/admin/remote-backend.env && set +a
    # - export REGISTRY_ID=$(terragrunt output -json --working-dir ${WORK_DIR}/infrastructure/${ENV}/registry | jq -r '.registry_id.value')
    
    # AUTH TO REGISTRY
    - |
      yc config profile create temp
      yc config set service-account-key "$YC_SERVICE_ACCOUNT_KEY_FILE"
      yc config set cloud-id "$YC_CLOUD_ID"
      yc config set folder-id "$YC_FOLDER_ID"
      # docker login --username iam --password-stdin cr.yandex <<< "$(yc iam create-token)"

    - export ANSIBLE_CONFIG=${WORK_DIR}/infrastructure/ansible/ansible.cfg

    # - echo "ðŸ“¦ PWD                          >>>     $(echo ${REGISTRY_ID})"
    - |
      args="ENV=$ENV APP=$APP SERVICE=$SERVICE"
      if [ -n "$SUBSERVICE" ]; then
        args="$args SUBSERVICE=$SUBSERVICE"
      fi
      make deploy $args
  rules:
    - if: '$CI_PIPELINE_SOURCE == "trigger"'    