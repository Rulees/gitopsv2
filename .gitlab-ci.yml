stages:
  - check_secrets
  - create_dev
  - deploy_dev
  - approve
  - create_prod
  - deploy_prod
  - manual


variables:
  WORK_DIR: "$CI_PROJECT_DIR"
  TF_PLUGIN_CACHE_DIR: "$CI_PROJECT_DIR/plugin-cache"
  TG_PARALLELISM: 10


cache:
  key: pluginsv4
  paths:
    - plugin-cache/



.install_default_deps:
  before_script:
    - |
      if command -v apt &> /dev/null; then
          apt update && apt install -y make coreutils jq curl sed grep openssh-client git
      elif command -v apk &> /dev/null; then
          apk --no-cache add make coreutils jq curl sed grep openssh git
      else
          echo "âž–âž– ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÐ¼Ñ‹Ð¹ Ð¿Ð°ÐºÐµÑ‚Ð½Ñ‹Ð¹ Ð¼ÐµÐ½ÐµÐ´Ð¶ÐµÑ€ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½."
          exit 1; fi



.terragrunt_config:
  script:

    ##
    # INSTALL DEFAULT PACKAGES
    ##

    - |
      if command -v apt &> /dev/null; then
          apt update && apt install -y python3 py3-pip py3-setuptools py3-wheel aws-cli docker.io
          curl -sSf https://atlasgo.sh | sh -s -- -y
          # service docker status && service docker start && usermod -aG docker $USER && docker run hello-world && service docker status
      elif command -v apk &> /dev/null; then
          apk --no-cache add python3 py3-pip py3-setuptools py3-wheel aws-cli docker
          curl -sSf https://atlasgo.sh | sh -s -- -y
      else
          echo "âž–âž– ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÐ¼Ñ‹Ð¹ Ð¿Ð°ÐºÐµÑ‚Ð½Ñ‹Ð¹ Ð¼ÐµÐ½ÐµÐ´Ð¶ÐµÑ€ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½."
          exit 1; fi

    ##
    # DECRYPT SECRETS
    ##
    
    - make decrypt_secrets
    
    
    ##
    # SETUP SECRETS
    ##

    - export YC_SERVICE_ACCOUNT_KEY_FILE=${WORK_DIR}/secrets/admin/yc_admin_sa_key.json
    - set -a && source ${WORK_DIR}/secrets/admin/remote-backend.env && set +a

    ##
    # Logs
    ##

    - echo "ðŸ“¦ PWD                          >>>     $(pwd)"
    - echo "ðŸ“¦ Ð¡Ð¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸Ð¸        >>>     $(ls -la)"
    - echo "ðŸ“¦ YC_SERVICE_ACCOUNT_KEY_FILE  >>>     $(cat ${YC_SERVICE_ACCOUNT_KEY_FILE} | head -c 30)"
    - echo "ðŸ“¦ AWS_ACCESS_KEY_ID            >>>     $(echo ${AWS_ACCESS_KEY_ID} | head -c 300)"
    - echo "ðŸ“¦ SA_COMPUTE_VIEWER            >>>     $(cat ${WORK_DIR}/secrets/ops/yc_compute_viewer_sa_key.json | head -c 50)"

    ##
    # CONFIGURE TERRAFORM TO USE YANDEX MIRROR
    ##

    - |
      cat <<EOF > ~/.terraformrc
      provider_installation {
        network_mirror {
          url = "https://terraform-mirror.yandexcloud.net/"
          include = ["registry.terraform.io/*/*"]
        }
        direct {
          exclude = ["registry.terraform.io/*/*"]
        }
      }
      EOF
    
    ##
    # CACHE
    ##

    - mkdir -p $TF_PLUGIN_CACHE_DIR
    # - terragrunt run --all providers mirror $TF_PLUGIN_CACHE_DIR --working-dir="${WORK_DIR}/infrastructure/dev/network" # APPLY ONLY AT FIRST SUCCESSFUL TIMES TO CREATE CACHE
    - ls -la $TF_PLUGIN_CACHE_DIR/registry.terraform.io

    ##
    # TERRAGRUNT CHECK
    ##

    - terragrunt hcl fmt
    - terragrunt hcl fmt --check
    # - terragrunt init --all -upgrade --non-interactive -lock=false --experiment-mode --working-dir="${WORK_DIR}" --filter='/**/infra*/dev/**/home/**'     #--filter='!./infrastructure/prod/**'  --filter='!./infrastructure/dev/vpc/soa/**' --filter='!./infrastructure/dev/vpc/home_serverless/**' --filter='!./infrastructure/dev/vpc/atlas/**' --filter='!./infrastructure/dev/vpc/autoscale/**' --filter='!./infrastructure/dev/vpc/loadbalance/**' --filter='!./infrastructure/dev/vpc/totemlounge/**'   --filter='!./infrastructure/dev/consul_server/**' --working-dir="${WORK_DIR}"
    # - terragrunt run --all validate --experiment-mode --working-dir="${WORK_DIR} --filter='/**/infra*/dev/**/home/**'


.ansible_config:
  script:

    - export ANSIBLE_CONFIG=${WORK_DIR}/infrastructure/ansible/ansible.cfg

    ##
    # DECRYPT SECRETS
    ##

    - make decrypt_secrets
    
    ##
    # Logs
    ##

    - echo "ðŸ“¦ PWD                          >>>     $(pwd)"
    - echo "ðŸ“¦ Ð¡Ð¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸Ð¸        >>>     $(ls -la)"
    - echo "ðŸ“¦ YC_SSH_KEY                   >>>     $(cat ${WORK_DIR}/secrets/admin/yc_ssh_key | head -c 30)"
    - echo "ðŸ“¦ GITLAB_ENV                   >>>     $(cat ${WORK_DIR}/secrets/ops/gitlab.env | head -c 300)"
    - echo "ðŸ“¦ SA_COMPUTE_VIEWER            >>>     $(cat ${WORK_DIR}/secrets/ops/yc_compute_viewer_sa_key.json | head -c 50)"
    - echo "ðŸ“¦ SA_SERVERLESS_DEPLOY         >>>     $(cat ${WORK_DIR}/secrets/ops/yc_serverless_deploy_sa_key.json | head -c 50)"
    - echo "ðŸ“¦ ENV_APP_SECRET               >>>     $(cat ${WORK_DIR}/secrets/dev/totemlounge/website/.env | head -c 30)"

    ##
    # SETUP SECRETS
    ##

    - chmod 600 ${WORK_DIR}/secrets/admin/yc_ssh_key
    - eval $(ssh-agent -s) && ssh-add ${WORK_DIR}/secrets/admin/yc_ssh_key 
    
    - make write_terragrunt_output_secrets_to_files


    ##
    # SERVERLESS
    ##

    # 1) GET YC CONTAINER REGISTRY ID
    - export YC_SERVICE_ACCOUNT_KEY_FILE=${WORK_DIR}/secrets/ops/yc_serverless_deploy_sa_key.json
    - set -a && source ${WORK_DIR}/secrets/admin/remote-backend.env && set +a
    - export REGISTRY_ID=$(terragrunt output -json --working-dir ${WORK_DIR}/infrastructure/${ENV}/registry | jq -r '.registry_id.value')
    - echo "ðŸ“¦ PWD                          >>>     $(echo ${REGISTRY_ID})"

        
    # 2) AUTH TO REGISTRY
    - |
      yc config profile create temp
      yc config set service-account-key "$YC_SERVICE_ACCOUNT_KEY_FILE"
      yc config set cloud-id "$YC_CLOUD_ID"
      yc config set folder-id "$YC_FOLDER_ID"
      docker login --username iam --password-stdin cr.yandex <<< "$(yc iam create-token)"
    

# check_secrets:
#   stage: check_secrets
#   image: frolvlad/alpine-bash
#   before_script: 
#     - !reference [.install_default_deps, before_script]
#   script:
#     - make check_secrets
#   rules:
#     - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH'


create_dev:
  stage: create_dev
  image: alpine/terragrunt:tf1.13.4
  variables:
    SOPS_KEYS: "admin dev ops"
  before_script: 
    - !reference [.install_default_deps, before_script]
  script:
    - !reference [.terragrunt_config, script]
    - |
      terragrunt apply  --all --non-interactive -lock=false -auto-approve --experiment-mode \
                        --working-dir="${WORK_DIR}"                                          \
                        --filter="{/**/infra*/dev/**/home/**} | [HEAD~3]" 
  # needs: [check_secrets]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH'




deploy_dev:
  stage: deploy_dev
  image: arkselen/ci:v6
  variables:
    ENV: "dev"
    SOPS_KEYS: "admin ops dev"
  script:
    - !reference [.ansible_config, script]
    - make deploy ENV=dev APP=home
  needs: [create_dev]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH'




approve:
  stage: approve
  image: frolvlad/alpine-bash
  before_script: 
    - !reference [.install_default_deps, before_script]
  script:
    - make approve
  needs: [deploy_dev]
  # when: manual
  allow_failure: false
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH'




create_prod:
  stage: create_prod
  image: alpine/terragrunt:tf1.13.4
  variables:
    SOPS_KEYS: "admin ops prod"
  before_script: 
    - !reference [.install_default_deps, before_script]
  script:
    - !reference [.terragrunt_config, script]
    - |
      terragrunt apply  --all --non-interactive -lock=false -auto-approve --experiment-mode \
                        --working-dir="${WORK_DIR}/infrastructure/dev"                       \
                        --filter='/**/infra*/dev/**/home/**'                                  \
                        # --filter='[main...HEAD]'
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH




deploy_prod:
  stage: deploy_prod
  image: arkselen/ci:v6
  variables:
    ENV: "prod"
    SOPS_KEYS: "admin ops prod"
  script:
    - !reference [.ansible_config, script]
    - make deploy ENV=prod APP=home
  needs: [create_prod]
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH



# MANUAL_JOBS>>>
rollback_infra_prod:
  stage: manual
  image: alpine/terragrunt:tf1.13.4
  variables:
    SOPS_KEYS: "admin"
    ENV: "prod"
  before_script:
    - !reference [.install_default_deps, before_script]
  script:
    - git fetch origin main
    - git checkout $(git log --merges origin/main --pretty=format:"%H" | sed -n 2p)
    - !reference [.terragrunt_config, script]
    - make create ENV=prod
  when: manual
  allow_failure: false
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'


rollback_deploy_prod:
  stage: manual
  image: arkselen/ci:v6
  variables:
    SOPS_KEYS: "admin ops prod"
    ENV: "prod"
  script:
    - git fetch origin main
    - git checkout $(git log --merges origin/main --pretty=format:"%H" | sed -n 2p)
    - !reference [.ansible_config, script]
    - make deploy ENV=prod
  when: manual
  allow_failure: false
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'




destroy_dev:
  stage: manual
  image: alpine/terragrunt:tf1.13.4
  variables:
    SOPS_KEYS: "admin"
  before_script: 
    - !reference [.install_default_deps, before_script]
  script:
    - !reference [.terragrunt_config, script]
    - make destroy ENV=dev
  when: manual
  allow_failure: false
  # rules:
  #   - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH


destroy_prod:
  stage: manual
  image: alpine/terragrunt:tf1.13.4
  variables:
    SOPS_KEYS: "admin"
  before_script: 
    - !reference [.install_default_deps, before_script]
  script:
    - !reference [.terragrunt_config, script]
    - make destroy ENV=prod
  when: manual
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH






deploy_cloud_function_trigger:
  stage: deploy_dev
  image: arkselen/ci:v8
  variables:
    ENV: "dev"
    SOPS_KEYS: "admin ops dev"
  script:

    - export ANSIBLE_CONFIG=${WORK_DIR}/infrastructure/ansible/ansible.cfg

    ##
    # DECRYPT SECRETS
    ##

    - make decrypt_secrets

    ##
    # SETUP SECRETS
    ##

    - export YC_SERVICE_ACCOUNT_KEY_FILE=${WORK_DIR}/secrets/admin/yc_admin_sa_key.json
    - set -a && source ${WORK_DIR}/secrets/admin/remote-backend.env && set +a
    - chmod 600 ${WORK_DIR}/secrets/admin/yc_ssh_key
    - eval $(ssh-agent -s) && ssh-add ${WORK_DIR}/secrets/admin/yc_ssh_key 
    
    - make write_terragrunt_output_secrets_to_files

    ##
    # DEPLOY
    ##

    - |
      args="ENV=$ENV APP=$APP SERVICE=$SERVICE DEPLOY_STATUS=in_process"
      if [ -n "$SUBSERVICE" ]; then
        args="$args SUBSERVICE=$SUBSERVICE"
      fi

    - echo "ðŸ“¦ ARGS                            >>>  $(echo ${args} | head -c 125)"
    - make deploy $args
  after_script:
    - apk add py3-requests
    - make add_tag_deploy_status
  rules:
    - if: '$CI_PIPELINE_SOURCE == "trigger"'


mark_all_instances_false:
  stage: deploy_dev
  image: arkselen/ci:v8
  variables:
    ENV: "dev"
    SOPS_KEYS: "admin ops dev"
  script:
    # DECRYPT SECRETS
    - make decrypt_secrets

    # SETUP SECRETS
    - chmod 600 ${WORK_DIR}/secrets/admin/yc_ssh_key
    - eval $(ssh-agent -s) && ssh-add ${WORK_DIR}/secrets/admin/yc_ssh_key 
    - export ANSIBLE_CONFIG=${WORK_DIR}/infrastructure/ansible/ansible.cfg


    - curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash && \
    - mv /root/yandex-cloud/bin/yc /usr/local/bin/yc
    - apk add py3-requests

    # SCRIPT
    - make mark_all_instances_false
  allow_failure: false
  when: manual
  rules:
    - if: '$CI_PIPELINE_SOURCE == "trigger"'
